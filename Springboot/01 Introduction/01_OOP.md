# Springboot Introduction
## 230223 OOP
### 목표
* OOP의 이해

## 객체의 3가지 요소
### 상태 유지 : 객체의 상태
* 객체는 상태 정보를 저장, 유지
* 속성은 변수로 정의
* 속성값의 변경으로, 객체의 상태 변경

### 기능 제공 : 객체의 책임
* 객체는 Method를 통해 기능 제공
* 캡슐화와 연관
* 외부로부터 직접 속성에 접근하여 변경 하는 것이 아니라
* 객체가 공유하는 Method로 기능이 제공

### 고유 식별자 제공 : 객체의 유일성
* 객체는 고유한 식별자를 가져야 함
* 속성을 통해 고유한 값 가짐
* DB에서 Unique Key, Primary Key 로 작성
  
## 개념 객체
* 웹 시스템에서의 Service에 해당
* Business Logic을 처리하는 부분
* Business Logic에서는 여러 객체가 서로 상호작용
* 객체가 제공하는 method를 통해 객체의 속성 변경

---

## 객체지향의 4대 특성
### 1. 캡슐화
* 객체의 속성(varialbe)을 보호하기 위해 사용

#### 장점
* 추상화 제공
  * 실제로 Method가 어떻게 동작하는지 외부에서 이해할 필요가 없음
  * 객체 단위로 프로그램 설계 가능
* 재사용성 향상
  * 캡슐화의 형태로 제공하여 객체의 모듈성과 응집도가 높음
* 유지보수가 용이

#### 무결성
* 캡슐화 코딩이라고하면, 
* 변수는 private 으로 선언, Method는 public 으로 선언하는 형태
* Getter/Setter를 제외 하고는 public method는 입력된 매개변수를 validation을 한 후에 실행
* validation을 통해 객체의 값을 바꾸거나, 값의 유효성 검사

#### Method 설계
* 속성에 대해 해당 상태를 변경하는 기능을 제공해야 함
* 실물 객체가 가진 기능을 모두 제공
* 각각의 Method는 서로 관련성이 있음
* 객체 안의 Method는 해당 객체 안의 속성을 처리
* Method 실행에 필요한 값들은 매개변수의 형태로 전달

#### Getter / Setter Method
* 외부에서 내부 속성에 직접 접근하지 않고, Getter / Setter 를 통해서 접근

#### CRUD Method
* 데이터 처리를 위한 기본적인 CRUD Method 제공

#### Business Logic Method
* 비즈니스 로직 처리를 위한 Method

#### 객체의 생명 주기 처리 Method
* destroy(), disconnect(), quit() 등 소멸에 대한 method

#### 객체의 영구성 관리 Method
* 영구성 속성에 대한 변경이 필요한 경우
* 외부 접근이 불가능 하도록 private 선언
* 내부의 Method를 통해서 사용

### 2. 상속화
* 하위로 내려갈수록 구체화
  
#### 장점
* 프로그램 구조에 대한 이해도 향상
  * 상위 클래스 구조를 통해 하위 클래스 동작 이해 가능
* 재사용성 향상
  * 상속을 이용하여, 해당 클래스에 필요한 속성 및 메소드를 모두 정의하지 않고 상속받아 사용 가능
* 확장성 향상
  * 일관된 형태의 클래스 객체를 추가하여 확장 가능
* 유지보수성 향상
  * 상속을 사용한 경우 일관된 형태로 작성 수정 가능

### 3. 다형성
* 다형성은 하나의 객체가 여러개의 형태로 변하는 것
* 오버라이딩

### 4. 추상화
* 모델링
* 객체를 속성과 행위로 표현
* 공통적인 부분, 특정 특성을 분리해서 재조합 하는 부분
* 다형성, 상속 모두 추상화에 속함

---

## 객체지향 설계 5원칙 SOLID
### 응집도와 결합도
* 좋은 소프트웨어 설계를 위해서는 결합도(coupling)는 낮추고 응집도(cohesion)는 높여야 한다.

#### 결합도
* 모듈(클래스)간의 상호 의존 정도를 나타내는 지표
* 결합도가 낮으면 모듈간의 상호 의존성이 줄어
* 객체의 재사용 및 유지보수가 유리

#### 응집도
* 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성
* 응집도가 높은 모듈은 하나의 책임에 집중하여 독립성이 높음

### 1. SRP 단일 책임 원칙
* Single Responsibility Principle
* 어떠한 클래스를 변경해야 하는 이유는 한가지 뿐이어야 한다.

### 2. OCP 개방 폐쇄 원칙
* Open Closed Principle
* 자신의 확장에는 열려있고, 주변의 변화에는 닫혀 있어야 한다.
* 상위 클래스 또는 인터페이스를 중간에 둠으로써
* 자신의 변화에는 폐쇄적이지만 인터페이스는 외부의 변화에 대해 확장을 개방해 줄 수 있다.
* ex) JDBC Interface

### 3. LSP 리스코프 치환 원칙
* Liskov Substitution Principle
* 서브 타입은 언제나 자신의 기반(상위) 타입으로 교체 할 수 있어야 한다.

### 4. ISP 인터페이스 분리 원칙
* Interface Segregation Principle
* 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
* 프로젝트 요구 사항과 설계에 따라서 SRP / ISP 를 선택

### 5. DIP 의존 역전 원칙
* Dependency Inversion Principle
* 자신보다 변하기 쉬운 것에 의존하지 말아야 한다.
* 