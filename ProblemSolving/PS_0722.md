# Problem Solving
## 220722 PS
### 목표
* 알고리즘 문제 풀이 방법 알기


### Problem Solving에 필요한 능력
#### 1. 구현능력
* 내가 생각하는 내용을 코드로 옮길 수 있는가?
* 필요한 변수의 선언과 간단한 전처리
* 정확하고 빠른 구현
* 나만의 템플릿

#### 2. 효율성
* 자주 사용하는 함수의 최적화
* 다른 풀이나 연습을 통해 효율적인 코드 작성
* 시간복잡도와 공간복잡도 계산 연습 및 고려하여 코드 작성

#### 3. 절차적 사고
* 전체적인 workflow 설계 능력
* 자료구조와 알고리즘 지식
* 적재적소에 맞는 알고리즘 선택 후 구현

#### 4. 디버깅
* 과정 속에서 틀린 부분 발견
* 테스트 케이스에 해당하지 않는 예외 케이스 탐색
* 코드를 읽는 능력


### 읽기와 분석
* 문제를 읽을 때, 어떤 부분을 초점을 두고 읽어야 할까?
* 문제의 조건들을 추상화 하는 연습
* 시간복잡도 / 공간복잡도 예상 및 고려

#### 시간복잡도
* 코드의 실행 시간에 미치는 요인? : 연산량!
* 연산량과 관계있는 요인? : 입력!
* 그러니 **입력을 보고 실행시간을 대충 예상**할 수 있다

* \* 연산과 \+ 연산의 속도 다르다
* 큰 수로 갈수록 연산속도 훨씬 오래걸린다
* 모든 연산의 시간을 고려할 수 없다
* 최악의 경우와 최선의 경우에도 다르다
* **대충 계산**해보자

#### Big O notation
* 점근적 표현범
* 시간과 공간차원에서 다룬다 : 시간복잡도, 공간복잡도
* 계산과 시스템에대한 감이 중요하다

![big O complexity chart](/ProblemSolving/img/2022-07-22-22-58-58.png)

O(n!) > O(2$^N$) > O(N$^2$) > O(N$log{N}$) > O(N) > O($\sqrt{n}$) > O($log{N}$) > O(1)


* O(1) : 단순한 수식의 표현
  * ex) sum = n(n + 1)/2

* O(N) : 입력이 N일 때 최악의 경우 N번만큼 연산
  * ex) 길이 N 수열에서 수 K 찾기

* O($log{N}$) : 
  * ex) 이분탐색 알고리즘 (up down 으로 찾기)
  * 계속 길이가 절반으로 줄어든다 : N = $2^{k}$, k = $log_{2}{N}$

* python에서 대충
  * 1M / 1sec : 안정적
  * 10M ~ 50M / 1sec : 대다수 가능
    * 좀 더 안정적으로 하려면 연산량을 줄여보자
    * O(2$^n$)을 다른 방법으로 O(N$^2$)으로 바꿀 수 있지 않을까?

* 문제를 많이 풀어보면서 복자도 계산도 계속 연습해보자


### 수 이어 쓰기
* Q : 숫자 N을 입력받아 1부터 그 수까지 모두 이어서 쓴 숫자의 자리수는?

* 시간 제한 : 1초
* 입력 제한 : 0 <= N <= 1,000,000,000

* 1초 제한에 max(N) = 10억
* O(N) 이상의 알고리즘은 불가능하다! 라는 감 잡기

#### 1. naive한 풀이 떠올려보기
```python
def solution(n):
    ret = 0
    for i in range(l, n + l):
        ret += len(str(i))
    return ret
```
>pythonic
```python
def solution(n):
    return sum(map(lambda x : len(str(x)), range(1, n + l)))
```
* 시간복잡도는 O(N$log{N}$)
  * 반복문 N
  * str연산 $log{N}$
  
#### 2. 중간 과정에 반드시 필요한 로직 생각하기
```python
def num_len(n):
    ret = 0
    while n :
        n /= 10
        ret += 1
    return ret
```
* 시간복잡도는 $log_{10}{N}$
  * 계속 10씩 나누기 때문에 (1/10 씩 줄어든다)

#### 3. 예제 입력과 예제 출력 매칭
```python
def solution(n):
    l, ret = len(str(n)), 0
    for i in range(1, l): 
        ret += i * (10**i - 10**(i - 1))
    ret += l * (n - 10 ** (l - 1) + 1)
    return ret
```

### 결과
* 문제풀이 방법에 필요한 기초 배경 지식 공부
* 문제풀이

---
### 참고
* [Tacademy 기초 알고리즘](https://www.youtube.com/watch?v=AhCib1thS7M&list=PL9mhQYIlKEhfg0aLdaO04wYUovLMXY4DU)